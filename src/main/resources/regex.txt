正则表达式引擎的种类： 有两种类型的引擎：文本导向(text-directed)的引擎和正则导向(regex-directed)的引擎。Jeffrey Friedl把他们称作DFA和NFA引擎。

 正则导向的引擎总是返回最左边的匹配

1、JAVA正则表达式的规则

1.1、自定义字符集
[abc]           a或b或c
[^abc]          除了a，b，c的其它字符
[a-zA-Z]        满足a-z范围的字符或A-Z范围的字符
例子：下面的正则表达式会匹配两个字符，第一个为小写字母，第二个为数字，文本串中已捕获的内容用红色表示。
正则表达式：“[a-z][0-9]”
文本串内容：“absef809sefdk1dfes12389”  ---->   f8,k1,s1

1.2、已定义字符集
.                   可以匹配非换行符以外的任何字符,能否匹配换行符是可配置的
\d                  数字，等价于[0-9]
\D（大写）           非数字，等价于[^0-9]
\s                  空白符，等价于[ \t\n\x0B\f\r]
\S（大写）           非空白符，等价于[^\s]
\w（大写）           字母、数字或下划线，等价于[a-zA-Z_0-9]
\W（大写）           非字母和数字，等价于[^\w]
例子：下面的正则表达式会匹配以非空白字符开头和非空白字符结尾，中间是“abc”的字符串，总共需要捕获5个字符，文本串中已捕获的内容用红色表示。
正则表达式：“\Sabc\S”
文本串内容：“abcd abc defabcyjkabc”    --->   fabcy

1.3 转义字符（不解释）
\t      The tab character ('\u0009')
\n      The newline (line feed) character ('\u000A')
\r      The carriage-return character ('\u000D')
\f      The form-feed character ('\u000C')
\a      The alert (bell) character ('\u0007')
\e      The escape character ('\u001B')
\cx     The control character corresponding to x

2.4 零宽度边界字符   ---->   零宽度边界字符，只会匹配一个位置而不会占有字符
^       行开始
$       行结束
\b      单词的开始边界或结束边界
\B      非单词的边界
例子：下面的正则表达式会匹配字符串“abc”，并且要求第一个字符‘a’的前面不是字母字符和数字字符，最后一个字符‘c’的后面不是字母字符和数字字符。
正则表达式总共需要捕获3个字符，文本串中已捕获的内容用红色表示。
正则表达式：“\babc\b”
文本串内容：“abc dabcd abc abcd -abc”   ----->   abc  abc  abc

2.5 贪婪重复模式（尽量多重复）
X表示一个合法的正则表达式
X?          X重复一次或0次
X*          X,重复0次或多次
X+          X重复至少1次
X{n}        X重复刚好n次
X{n,}       X重复至少n次
X{n,m}      X重复至少n次，最多m次
例子：下面的正则表达式会匹配以a开头和a界结尾的,中间有尽可能多的其它字符，且其它字符要求至少有一次，文本串中已捕获的内容用红色表示。
正则表达式：“a.+a”
文本串内容：“zxyabcdefasseaa09876”   ----->   abcdefasseaa

2.6 懒惰重复模式（尽量少重复）
X??         X重复一次或0次
X*?         X,重复0次或多次
X+?         X重复至少1次
X{n}?       X重复刚好n次
X{n,}?      X重复至少n次
X{n,m}?     X重复至少n次，最多m次
例子：下面的正则表达式会匹配以a开头和a界结尾的,中间有尽可能少的其它任意字符，且其它任意字符要求至少有一次。文本串中已捕获的内容用红色表示。
正则表达式：“a.+?a”
文本串内容：“zxyabcdefasseaa09876”   ----->   abcdefa

2.7 逻辑运算符
X和Y分别表示两个正则表达式
XY先满足正则表达式X，然后满足正则表达式Y的正则表达式
X|Y 满足正则表达式X或满足正则表达式Y的正则表达式
注意优先级，X|YZ 等价于 X|(YZ)，而（X|Y）Z表示XZ|YZ
正则表达式：“a(b|c)d”
文本串内容：“zxyabcdefacdeaabd876”   ---->    acd     abd

2.8 括号
在正则表达式中的作用有两个，一个和四则运算中的括号相同，用来改变优先级，另一个用于分组捕获。
分组捕获又分为两种，一种是自定义命名的分组，还有一种是未命名的分组（或者称为自动编号分组）。
命名分组的格式为：（?<name>X），其中X表示一个正则表达式
例子：下面的正则表达式表示已数字开头，中间是字母，以数字结尾的字符串。
名为letter的捕获组捕获符合该正则表达式中间为字母的部分。文本串中捕获的内容用红色表示。
正则表达式：“\d+(?<letter>[a-zA-Z]+)\d+”
文本串内容：“0123ab456def gisd4ZDG6zz”    ----->  0123ab456  4ZDG6
名为letter的捕获组中的内容为：“0123ab456def gisd4ZDG6zz”   ----->  ab  ZDG

对于未命名分组，每一对括号实际上都是一对分组，正则表达式引擎会在编译该表达式的时候会从左到右扫描正则表达式，对未命名分组进行编号。
遇到的第1个左括号（和相应匹配的右括号）是第1组，遇到的第2个左括号（和相应匹配的右括号）是第2组，……。第0组的内容匹配的是整个正则表达式。
实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，
第二遍只给自定义命名组分配，也就是说自定义命名分组也是有编号的，且所有自定义命名组的组号都大于未命名的组号。


2.9 特殊字符的匹配
对于一些在正则表达式中具有特殊含义的特殊字符，比如“{”，“*”“\”等等，如果我们想在文本串中捕获它们，就只能通过转义的方式。
比如我们想匹配文本串中以“{”花括号开头，花括号结尾“}”，中间有任意数量其它字符,且其它任意字符尽可能少。
我们的正则表达式就可以写成“\{.*？\}”，它可以匹配以下字符串中的“abcde{fghi{jklmn}op}xyz”  ---->  {fghi{jklmn} 。

正则表达式：“\\.*？\\” 表示已“\”开头和“\”结尾中间为任意数量且尽可能少的其它字符。
它可以匹配以下字符串中的“abcde\fghi\jklmn\op\xyz”  ---->  \fghi\   \op\


实现步骤：
step1：正则表达式字符串词法分析
普通字符、量词、预定义字符&字符集、转义、操作符




